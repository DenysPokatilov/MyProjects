using System;
using System.IO;
using System.Net;

namespace MyPractice
{

    public class WebClient
    {

        public static void Main(string[] args)
        {
            // Значение URL всё так же запрашивается у пользователя, а не берётся параметром командной строки 
            // (т.е. из массива args этого метода)

            Console.WriteLine("Пожалуйста введите URL адресс");
            string http = "http://www.";
            string URL = Convert.ToString(http + Console.ReadLine()); // Названия переменной URL плохое!

            // В С# namespace'ы, классы, методы, свойства принято называть, используя т.н. Pascal Case, то есть 
            // когда все слова в названии пишутся слитно и каждое слово с заглавной буквы (см. namespace и имя 
            // класса в этом примере). 
            //
            // Переменные же принято называть, используя т.н. Camel Case, то есть когда все слова в названии пишутся
            // слитно, при этом первое слово с маленькой буквы, а остальные с заглавной (например, maxCreditLimit).
            //
            // Единственные случаи, когда позволительно использовать все заглавные буквы в названии - это для имен
            // констант, и то лучше избегать этой практики и использовать Pascal Case для констант также.
            //
            // Все имена должны быть ОСМЫСЛЕННЫМИ! Глаголы использовать только для имен методов, так как они что-то делают.
            // Для имен классов использовать только существительные, так как классы описывают некие сущности. Для имен 
            // переменных использовать только существительные и предикаты (например, requestUrl, isSuccess).

            WebRequest GETURL = WebRequest.Create(URL); 
            
            // Название переменной GETURL крайне отвратительно! Во-первых, потому что заглавныеми буквами. А во-вторых,
            // потому что GETURL - это глагол. Согласно описанному выше, это было бы подходящее имя для метода, но не
            // для переменной.

            Stream objStream = GETURL.GetResponse().GetResponseStream(); // Почему не используешь конструкцию using?

            // Поток objStream так в итоге нигде и не закрывается.

            StreamReader objReader = new StreamReader(objStream); // Тот же вопрос: почему не используешь конструкцию using?

            // К тому же плохие названия переменных. Что значат objStream и objReader? Эти названия не несут никакой
            // вспомогательной информации. В имени objReader угадывается object reader, то есть буквально что-то, что
            // читает объект или из объекта. Поток - это, конечно, в буквальном смысле объект, но экземпляр любого типа 
            // является объектом, то есть такое название не несёт никакой смысловой нагрузки. Согласись, куда более
            // выразительными были бы названия responseStream и responseReader (ну, или просто stream и reader для краткости,
            // без всякого obj - участок кода маленький и сразу видно, что это за stream и reader).

            // Не забывай, программист больше времени проводит за ЧТЕНИЕМ кода, а не его созданием. Поэтому очень важно,
            // чтобы код был легко читаемым, понятным, с хорошими и выразительными именами, ясной логикой. Ты, прежде всего,
            // сам себе будешь за это благодарен через какое-то время.

            string Line = ""; // Плохое название: переменная с заглавной буквы, а должна быть с маленькой.

            while (Line != null)
            {
                Line = objReader.ReadLine();
                if (Line != null)
                {
                    Console.WriteLine("{0}", Line); 
                    // Зачем, если строку никак не форматируешь, а выводишь как есть?
                    // Можно ведь просто Console.WriteLine(Line);
                }

            }

            // Можно было бы вообще обойтись без использования дополнительной переменной Line и дублирования
            // условия (Line != null), а написать так:
            //
            // while (objReader.Peek() >= 0) {
            //     Console.WriteLine(objReader.ReadLine());
            // }
            //
            // Вообще всегда надо стараться максимально избегать дублирования связанного кода. Видишь, что где-то
            // дублируешь вот так вот одно и то же условие или какую-то логику, подумай, почему это так и как бы
            // его так переписать, чтобы этого дублирования не было. Помни о т.н. DRY принципе: Don't Repeat Yourself!

            var File = new FileStream(@"D:\GetTest.html", FileMode.OpenOrCreate); // Зачем?

            // Мы же договорились, что ты в коде не создаешь никаких файлов, а просто выводишь всё в консоль. Если захотим
            // отправить содержимое в файл, то восользуемся перенаправлением потока (program.exe > result.txt)

            // Весь код, который идёт дальше, совершенно нам не нужен. Ты уже всё вывел в консоль в своём while-цикле выше.

            StreamWriter s = new StreamWriter(File);

            s.Write(objReader.ReadToEnd());

            s.Write("111!");
            s.Close();


            Console.ReadKey();
        }

    }

}



